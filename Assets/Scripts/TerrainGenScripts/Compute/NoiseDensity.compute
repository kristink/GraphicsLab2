#pragma kernel Density
#include "/Includes/Density.compute"
#include "/Includes/Noise.compute"

// Noise settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;

float4 params;

[numthreads(numThreads,numThreads,numThreads)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    float3 pos = centre + id * spacing - boundsSize/2;
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise((pos+offsetNoise) * frequency + offsets[j] + offset);
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    //noise = test123(pos +offsetNoise, noiseScale, persistence, noiseWeight); 
    //float test = sin(pos.z)*2;
    /*float a = 0.02;
    float b = 6;
    float c = 6.4;
    float a_1 = 0.05;
    float f = b * sin(pos.x * a) + b * sin(pos.z * a);
    float f_1 = c * cos(pos.x * a_1) + c * pow(cos(pos.z * a_1), 2);
    float f_2 = c * sin(pos.x * a * 2) + c * pow(sin(pos.z * a * 2), 2);
    float f_3 = c * 0.3 * pow(cos(pos.x * a_1 * 1.2), 2) + c * 0.3 * cos(pos.z * a_1 * 1.1);
    float g = f -f_1 + f_2 + f_3;
    noise = g + snoise(pos)*0.4; //test -test3 * 0.3;// */
    float finalVal = -(pos.y + floorOffset) + noise *noiseWeight + (pos.y % params.x) * params.y;
    
        
    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }

    if (closeEdges) {
        float3 edgeOffset = abs(pos*2)-worldSize + spacing/2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x,edgeOffset.y),edgeOffset.z)));
        finalVal = finalVal * (1-edgeWeight) - 100 * edgeWeight;
        
    }
    
    int index = indexFromCoord(id.x,id.y,id.z);
    points[index] = float4(pos, finalVal);
    
}
